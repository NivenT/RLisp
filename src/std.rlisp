(defun caar [lst] (car (car lst)))
(defun cadr [lst] (car (cdr lst)))
(defun cdar [lst] (cdr (car lst)))
(defun cddr [lst] (cdr (cdr lst)))
(defun caaar [lst] (car (car (car lst))))
(defun caadr [lst] (car (car (cdr lst))))
(defun cadar [lst] (car (cdr (car lst))))
(defun caddr [lst] (car (cdr (cdr lst))))
(defun cdaar [lst] (cdr (car (car lst))))
(defun cdadr [lst] (cdr (car (cdr lst))))
(defun cddar [lst] (cdr (cdr (car lst))))
(defun cdddr [lst] (cdr (cdr (cdr lst))))
(defun caaaar [lst] (car (car (car (car lst)))))
(defun caaadr [lst] (car (car (car (cdr lst)))))
(defun caadar [lst] (car (car (cdr (car lst)))))
(defun caaddr [lst] (car (car (cdr (cdr lst)))))
(defun cadaar [lst] (car (cdr (car (car lst)))))
(defun cadadr [lst] (car (cdr (car (cdr lst)))))
(defun caddar [lst] (car (cdr (cdr (car lst)))))
(defun cadddr [lst] (car (cdr (cdr (cdr lst)))))
(defun cdaaar [lst] (cdr (car (car (car lst)))))
(defun cdaadr [lst] (cdr (car (car (cdr lst)))))
(defun cdadar [lst] (cdr (car (cdr (car lst)))))
(defun cdaddr [lst] (cdr (car (cdr (cdr lst)))))
(defun cddaar [lst] (cdr (cdr (car (car lst)))))
(defun cddadr [lst] (cdr (cdr (car (cdr lst)))))
(defun cdddar [lst] (cdr (cdr (cdr (car lst)))))
(defun cddddr [lst] (cdr (cdr (cdr (cdr lst)))))
(defun caaaaar [lst] (car (car (car (car (car lst))))))
(defun caaaadr [lst] (car (car (car (car (cdr lst))))))
(defun caaadar [lst] (car (car (car (cdr (car lst))))))
(defun caaaddr [lst] (car (car (car (cdr (cdr lst))))))
(defun caadaar [lst] (car (car (cdr (car (car lst))))))
(defun caadadr [lst] (car (car (cdr (car (cdr lst))))))
(defun caaddar [lst] (car (car (cdr (cdr (car lst))))))
(defun caadddr [lst] (car (car (cdr (cdr (cdr lst))))))
(defun cadaaar [lst] (car (cdr (car (car (car lst))))))
(defun cadaadr [lst] (car (cdr (car (car (cdr lst))))))
(defun cadadar [lst] (car (cdr (car (cdr (car lst))))))
(defun cadaddr [lst] (car (cdr (car (cdr (cdr lst))))))
(defun caddaar [lst] (car (cdr (cdr (car (car lst))))))
(defun caddadr [lst] (car (cdr (cdr (car (cdr lst))))))
(defun cadddar [lst] (car (cdr (cdr (cdr (car lst))))))
(defun caddddr [lst] (car (cdr (cdr (cdr (cdr lst))))))
(defun cdaaaar [lst] (cdr (car (car (car (car lst))))))
(defun cdaaadr [lst] (cdr (car (car (car (cdr lst))))))
(defun cdaadar [lst] (cdr (car (car (cdr (car lst))))))
(defun cdaaddr [lst] (cdr (car (car (cdr (cdr lst))))))
(defun cdadaar [lst] (cdr (car (cdr (car (car lst))))))
(defun cdadadr [lst] (cdr (car (cdr (car (cdr lst))))))
(defun cdaddar [lst] (cdr (car (cdr (cdr (car lst))))))
(defun cdadddr [lst] (cdr (car (cdr (cdr (cdr lst))))))
(defun cddaaar [lst] (cdr (cdr (car (car (car lst))))))
(defun cddaadr [lst] (cdr (cdr (car (car (cdr lst))))))
(defun cddadar [lst] (cdr (cdr (car (cdr (car lst))))))
(defun cddaddr [lst] (cdr (cdr (car (cdr (cdr lst))))))
(defun cdddaar [lst] (cdr (cdr (cdr (car (car lst))))))
(defun cdddadr [lst] (cdr (cdr (cdr (car (cdr lst))))))
(defun cddddar [lst] (cdr (cdr (cdr (cdr (car lst))))))
(defun cdddddr [lst] (cdr (cdr (cdr (cdr (cdr lst))))))
(defun abs [n] ((if (> n 0) + -) n))
(defun fact [n] (if (<= n 1) 1 (* n (fact (- n 1)))))
(defun round [n] (if (>= (- n (floor n)) .5) (ceil n) (floor n)))
(defun null? [lst] (equal? lst nil))
(defun 1+ [n] (+ n 1))
(defun 1- [n] (- n 1))
(defun length [lst] (if (null? lst) 0 (1+ (length (cdr lst)))))
(defun join [lst1 lst2] 
	(if (null? lst1) 
		lst2 
		(cons (car lst1) (join (cdr lst1) lst2))))
(defun append [lst1 item] (join lst1 (list item)))
(defun list* [&rest lists]
	(join (most lists) (last lists)))
(defun member [elem lst]
	(if (null? lst)
		nil
		(if (equal? (car lst) elem)
			t
			(member elem (cdr lst)))))
(defun assoc [elem lst]
	(if (null? lst)
		nil
		(if (equal? (car (car lst)) elem)
			(cdr (car lst))
			(assoc elem (cdr lst)))))
(defun any? [func lst]
	(if (null? lst)
		nil
		(if (func (car lst))
			(car lst)
			(any? func (cdr lst)))))
(defun all? [func lst]
	(if (null? lst)
		t
		(if (not (func (car lst)))
			nil
			(all? func (cdr lst)))))
(defun map [func lst]
	(if (null? lst)
		nil
		(cons (func (car lst)) (map func (cdr lst)))))
(defun filter [pred lst]
	(if (null? lst)
		nil
		(if (pred (car lst))
			(cons (car lst) (filter pred (cdr lst)))
			(filter pred (cdr lst)))))
(defun foldl [func init lst]
	(if (null? lst)
		init
		(foldl func (func init (car lst)) (cdr lst))))
(defun foldr [func init lst]
	(if (null? lst)
		init
		(foldr func (func (last lst) init) (most lst))))
(defun range [min max &optional (step 1)]
	(if (>= min max)
		nil
		(cons min (range (+ min step) max step))))
(defun make-list [elem size]
	(if (<= size 0)
		nil
		(cons elem (make-list elem (1- size)))))
(defun last [lst]
	(if (null? lst)
		nil
		(if (null? (cdr lst))
			(car lst)
			(last (cdr lst)))))
(defun complement [pred]
	(lambda [x] (not (pred x))))
(defun reverse [lst]
	(if (null? lst)
		nil
		(append (reverse (cdr lst)) (car lst))))
(defun flatten (lst)
	(cond 	((null? lst) nil)
			((list? lst) (join (flatten (car lst)) (flatten (cdr lst))))
			(t (list lst))))
(defun nthmost [n lst]
	(if (= 0 n)
		lst
		(most (nthmost (1- n) lst))))
(defun partition (lst size &optional (step size) (runninglist nil))
	(if (< (length lst) size)
		runninglist
		(partition (nthcdr step lst) size step (append runninglist 
			(nthmost (- (length lst) size) lst)))))
		
		
(defmacro when [pred body]
	`(if ,pred ,body nil))
(defmacro unless [pred body]
	`(if (not ,pred) ,body nil))
(defmacro and [&rest preds]
	`(if (null? (quote ,preds))
		t
		(if (car (quote ,preds))
			(apply and (cdr (quote ,preds))))))
(defmacro or [&rest preds]
	`(if (null? (quote ,preds))
		nil
		(if (car (quote ,preds))
			(car (quote ,preds))
			(apply or (cdr (quote ,preds))))))
(defmacro cond [&rest conditions]
	`(if (null? (quote ,conditions))
		nil
		(if (eval (caar (quote ,conditions)))
			(eval (cadar (quote ,conditions)))
			(apply cond (cdr (quote ,conditions))))))
(defmacro dolist [var lst &rest body]
	`(if (null? (quote ,lst))
		nil
		(progn (let ((,var (car (quote ,lst))))
			(apply progn (quote ,body)))
			(apply dolist (list* (quote ,var) (cdr (quote ,lst)) (quote 
				,body))))))
(defmacro dotimes [var start stop inc &rest body]
	`(if (>= ,start ,stop)
		nil
		(progn (let ((,var ,start))
			(apply progn (quote ,body)))
			(apply dotimes (list* (quote ,var) (+ ,inc ,start) ,stop ,inc
				(quote ,body))))))